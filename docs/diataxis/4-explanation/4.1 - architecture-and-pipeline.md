## Explanation: Architecture and End-to-End Pipeline

Metrics Reporter is a .NET 8 console application plus a Spectre CLI front-end that turns AltCover/OpenCover coverage, Roslyn metrics, and SARIF violations into a single JSON tree and HTML dashboard. This document explains the moving parts so you can reason about changes or extend the pipeline safely.

### High-level flow

1. **MSBuild orchestration** – `GenerateMetricsDashboard` (defined in `build/Targets/code-metrics.targets`) runs after the solution build. It locates every AltCover XML, Roslyn metrics XML, SARIF file, thresholds, baseline path, and suppression settings, then invokes `MetricsReporter.exe` with the assembled argument list. If `AltCoverEnabled=true`, the build also runs `CollectCoverage` beforehand.
2. **Document loaders** – Each data source has a minimal I/O component (e.g., `IRoslynMetricsDocumentLoader`, `AltCoverDocumentLoader`, `SarifDocumentLoader`). These read files into strongly typed domain objects without mixing aggregation logic.
3. **Parsers and walkers** – Roslyn metrics use `RoslynMetricsDocumentWalker`, AltCover uses `AltCoverMetricsParser`, SARIF uses `SarifDocumentAggregator` plus `SarifRuleViolationFactory`. Every parser emits `ParsedCodeElement` nodes that describe assemblies, namespaces, types, or members with normalized fully qualified names (FQNs).
4. **Aggregation** – `MetricsAggregationService` merges parsed trees into a single Solution → Member hierarchy. `StructuralElementMerger` reconciles nodes by FQN, `MemberFilter` removes compiler noise, and metric dictionaries are combined using semantic rules (sum counts, pick the non-null coverage value, etc.).
5. **Baseline + threshold evaluation** – `BaselineLifecycleService` copies the previous `MetricsReport.g.json` into `MetricsBaseline.g.json` when requested (`ReplaceMetricsBaseline=true`). After aggregation, `ThresholdEvaluator` compares every metric against `metadata.thresholdsByLevel` and computes `delta` vs. baseline.
6. **Suppression analysis** – `SuppressedSymbolsService` walks source folders listed in `SourceCodeFolders` and maps `[SuppressMessage]` attributes to Roslyn metric identifiers (`CA1506 → RoslynClassCoupling`, etc.). The resulting `SuppressedSymbols.g.json` is merged back into the main tree so UI and CLI can hide suppressed nodes by default.
7. **Rendering** – `HtmlTableGenerator` plus a modular JavaScript bundle transform the JSON tree into `MetricsReport.html`. `HtmlScriptGenerator` injects modules for filtering, detailing, awareness slider logic, tooltips, and persisted state. DOM nodes are cached so sliders and filters merely toggle `data-hiddenBy*` flags instead of reflowing the table from scratch.

### Key design decisions

- **Strict symbol normalization** – `SymbolNormalizer` converts AltCover `Namespace.Type::Method(Args)` and Roslyn `void Type.Method(...)` into the same `Namespace.Type.Method(...)` format. Without this, the aggregator would produce duplicate nodes and inaccurate deltas.
- **Failure on duplicate coverage** – If the same symbol appears in two AltCover XML files, the parser throws. This prevents silently overwriting coverage from parallel runs.
- **Interface-first services** – Every major subsystem exposes interfaces (`IMetricsReportPipeline`, `IBaselineLifecycleService`, `ISuppressedSymbolsService`, etc.) so tests can substitute fakes and CLI commands stay decoupled from implementation details.
- **HTML-first UX** – Detail/Awareness sliders, all/changes/new toggles, and `localStorage` persistence were prioritized because the dashboard is the main entry point for humans. The UI is intentionally ES5-compatible and relies on precomputed caches for performance on large solutions (>50k nodes).

### Threading and performance

- The console app runs on a single thread—it processes parsed documents sequentially to keep the logic deterministic and to simplify future AI maintenance.
- `System.Text.Json` with pooled buffers writes the final report without intermediate allocations.
- AltCover / Roslyn / SARIF parsing remains the largest cost, so each parser only loads what it needs and discards the rest immediately. Iterator coverage reconciliation and suppression analysis operate on in-memory dictionaries to avoid repeated traversals.

### Extending the pipeline

- **New metrics** – Add descriptors in `MetricDescriptorCatalog`, extend `MetricIdentifier`, update `thresholdsByLevel`, and ensure the HTML renderer knows how to format the new metric (unit, color rules).
- **Additional data sources** – Implement `IDocumentLoader` + `IDocumentParser` pair that emits `ParsedCodeElement` nodes. Hook the parser into `MetricsReportPipeline` before `MetricsAggregationService`.
- **Custom dashboards** – Consumers can ignore `MetricsReport.html` and build their own visualizations from `MetricsReport.g.json`, but they must preserve the schema documented in the reference section to remain compatible with `metrics-reader`.

### Baseline rotation summary

1. `ReplaceMetricsBaseline=true` (MSBuild property) activates automatic rotation.
2. Before aggregation, if the baseline file is missing but the previous report exists, copy the report to the baseline path.
3. After generating the new report, archive the old baseline to `MetricsReportStoragePath` with a timestamp suffix and overwrite the baseline with the fresh report.
4. Subsequent runs immediately have deltas ready—no manual copies required.

### HTML dashboard highlights

- **Detailing slider** – Limits tree depth (Namespace → Type → Member). Uses cached parent-child maps; no DOM rebuild.
- **Awareness slider** – Switches between All/Warning/Error, automatically keeping ancestor rows visible so context isn’t lost.
- **Filter box** – Debounced at 200 ms, matches substrings across FQN, rule IDs, and file paths. Results toggle `data-hiddenByFilter`.
- **Tooltips** – One tooltip host reused for metrics, suppressions, and symbols to avoid dozens of event handlers.
- **Actions** – Buttons for “Expand all”, “Collapse all”, copy/canonical link, `localStorage` reset. Clipboard operations rely on the modern `navigator.clipboard` API with a fallback.

Understanding these decisions helps diagnose regressions (e.g., mismatched FQNs, missing deltas, sluggish dashboards) and guides future improvements.

