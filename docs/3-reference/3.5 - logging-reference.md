## Logging reference (for contributors)

This document explains how logging is wired in MetricsReporter, how to add new logs, and how to use the shared helpers.

### Logger creation
- Prefer constructor injection of `ILogger<T>` for services, pipelines, and parsers.
- CLI composition roots register logging with `ServiceCollection` and use `LoggerFactoryBuilder.Create(logPath, minimumLevel, includeConsole, verbosity)` to add a console logger plus an optional file sink. The `verbosity` parameter controls console formatting (timestamp display).
- Avoid static loggers. Use scopes (`using var scope = logger.BeginScope(new { ... });`) to attach context such as solution, metrics directory, script path, or output locations.

### Verbosity and levels
- Verbosity mapping: `quiet|minimal` → `LogLevel.Warning`, `normal` → `LogLevel.Information`, `detailed` → `LogLevel.Debug`.
- Level conventions:
  - Information: milestones (start/finish, file load/write, counts, durations).
  - Warning: recoverable anomalies (timeouts, skips, fallback paths).
  - Error: failures; include `exception` where available.
- Use structured templates, not interpolated strings: `logger.LogInformation("Parsing metrics file {Path}", path);`.

### File sink
- `LoggerFactoryBuilder` adds a `FileLoggerProvider` when `logFilePath` is provided or inferred; the provider uses shared `FileShare.ReadWrite | FileShare.Delete` to reduce contention.
- Console output: uses `MinimalConsoleFormatter` with single-line messages. Timestamps are omitted in `normal` verbosity for cleaner output; included in other verbosity levels (`quiet`, `minimal`, `detailed`). File logs always include UTC timestamps.

### Helpers to reuse
- `LogTruncator.Truncate(value, limit)` with `LogTruncator.DefaultLimit` (4000) for stdout/stderr logging on failures.
- Process runs: `ProcessRunner` logs start, exit code, duration, and truncated streams on non-zero/timeout.
- Script execution: `ScriptExecutionService` logs start/end, exit code, and truncates stdout/stderr on failure; wraps script path/working directory in a scope.

### Patterns to follow
- Always include key context: solution name, metrics directory, input/output paths, script path, baseline path, storage path, or command name.
- Capture exceptions with `logger.LogError(exception, "...")`; avoid string-concatenating exception messages.
- Keep flow linear; avoid logging inside tight loops unless at Debug level.
- Tests: prefer `NullLogger<T>` or `TestLogger<T>` (see `MetricsReporter.Tests/TestHelpers/TestLogger.cs`) instead of file-based loggers.
- When adding new CLI features, thread verbosity into `LoggerFactoryBuilder.FromVerbosity(...)` and pass the resulting factory into new services.

### Adding logging to new code
1. Inject `ILogger<YourType>` (or accept an `ILoggerFactory` when a factory is needed).
2. If launching external processes or I/O, log start, duration, exit code/result, and truncated outputs on failure.
3. Wrap the operation with a `BeginScope` that captures identifiers (paths, command, metric, project).
4. Choose levels per the conventions above; keep messages structured and concise.

