## Reference: Suppression Authoring (Symbol and Global)

Authoritative rules for writing `[SuppressMessage]` entries that Metrics Reporter ingests into `SuppressedSymbols.g.json` and renders in HTML/CLI with suppression overlays.

### When to suppress
- Use suppression to keep the metric visible but marked as intentionally ignored (preferred over exclusion).
- Consider suppression when a warning is noise (e.g., configuration-driven guards, dummy nodes, defensive branches) and fixing it would not increase confidence.
- For OpenCover metrics, prefer suppression so coverage values stay in the report (avoid attribute-based exclusion that removes rows).

### Supported attribute placements
- **Symbol-level**: attribute sits on the type/member/property itself.
- **Assembly-level**: attribute sits at assembly/module scope (e.g., in `GlobalSuppressions.cs`) using `[assembly: SuppressMessage(..., Target = "...")]` or `[module: SuppressMessage(..., Target = "...")]`.
- The effect is the same (suppression by `Target`); they differ only by where the attribute lives.

### Target rules (assembly-level suppressions) — critical
- Metrics Reporter makes decisions **only by `Target`**. `Scope` is ignored by the engine and kept only for human/FxCop familiarity. You may include `Scope`, but a valid `Target` is mandatory for assembly-/module-level suppressions to work.
- `Target` must use the FxCop-style prefix plus fully qualified name:  
  - Type: `~T:Namespace.Type` (nested types: `Outer+Inner` → `Outer.Inner`).  
  - Method: `~M:Namespace.Type.Method(params)` (parameters ignored after normalization → `Method(...)`).  
  - Property/Event/Field: `~P:`, `~E:`, `~F:` behave like members without parameters.  
- Metrics Reporter normalizes:
  - Replaces `+` with `.` for nested types.
  - Strips parameter details to `(...)` for methods.
  - Strips generic arguments from type names.
  - Uses `RuleId` → metric mapping (`CA1506` → `RoslynClassCoupling`; `OpenCoverBranchCoverage` stays as-is).

### How Metrics Reporter consumes suppressions
- Roslyn scan collects symbol- and assembly-level `SuppressMessage` attributes and writes `SuppressedSymbols.g.json`.
- Metrics rendering/CLI join suppressions by normalized FQN + metric; HTML shows suppressed styling and justification tooltip. CLI `--include-suppressed` controls visibility in text output (HTML always shows suppressed badge).
- Suppressions are **not inherited**: `~T:Namespace.Type` affects only the type, not its members. Use `~M:`/`~P:`/`~E:` for specific members.
- Choose assembly-level placement when the rationale applies to the entire type (or nested type tree) and repeating the justification on each member would be redundant. Choose symbol-level placement when only a specific member needs suppression while the rest of the type remains unsuppressed.

### Writing symbol-level suppressions (examples)
```csharp
using System.Diagnostics.CodeAnalysis;

namespace MetricsReporter.Aggregation;

[SuppressMessage(
    "OpenCoverSequenceCoverage",
    "OpenCoverSequenceCoverage",
    Justification = "Defensive branches for excluded assemblies are noise in coverage.")]
internal sealed class StructuralElementMerger
{
    [SuppressMessage(
        "OpenCoverBranchCoverage",
        "OpenCoverBranchCoverage",
        Justification = "Dummy vs real member creation paths are exercised indirectly.")]
    public void CreateNewMember(...)
    {
    }
}
```

### Writing assembly-level suppressions (examples)
Place these in `GlobalSuppressions.cs` (any file is fine; it’s the assembly/module target that matters).

```csharp
using System.Diagnostics.CodeAnalysis;

[assembly: SuppressMessage(
    "OpenCoverBranchCoverage",
    "OpenCoverBranchCoverage",
    Scope = "type", // optional for clarity; engine uses Target
    Target = "~T:MetricsReporter.Aggregation.StructuralElementMerger",
    Justification = "Configuration-driven guards dominate branches; exercising all would be artificial.")]

[assembly: SuppressMessage(
    "Microsoft.Maintainability",
    "CA1506:Avoid excessive class coupling",
    Scope = "member", // optional; Target drives matching
    Target = "~M:MetricsReporter.Aggregation.MetricsAggregationService+AggregationWorkspaceWorkflow.Run(System.Threading.CancellationToken)",
    Justification = "Workflow complexity validated by higher-level service tests; remaining branches are defensive.")]
```

### Checklist for good suppressions
- Choose the right category and rule id:
  - OpenCover: `OpenCoverBranchCoverage`, `OpenCoverSequenceCoverage`.
  - Roslyn: FxCop-style categories (`Microsoft.Maintainability`) with rule ids (`CA1506`).
  - SARIF: use the rule id emitted by the analyzer (e.g., `IDE0059`).
- Provide a concise, actionable justification (why suppression is safe, not just “noise”).
- Ensure `Target` matches the normalized FQN format above; nested types use `+`, methods include parentheses.
- Prefer suppression over exclusion; keep metrics visible.
- After adding suppressions, run `dotnet tool run metricsreporter read --include-suppressed` (or generate the report) to verify suppressed entries appear with the intended justification.


